import asyncio
import os
import json
import shutil
from pathlib import Path
import pytest
import httpx
from unittest.mock import patch, MagicMock
import pytest_asyncio

from graphrag_agent.tools.content_parser import (
    AsyncPageContentParser,
    AsyncMarkdownParser,
    AsyncLangflowDocsMarkdownParser,
    AsyncPythonComponentParser,
    AsyncPythonSampleParser,
)

# Constants for testing
TEST_OUTPUT_DIR = Path(__file__).parent / "test_output"
HTML_OUTPUT_FILE = "webpage_content.json"
MARKDOWN_PREFIX = "markdown_"
LANGFLOW_DOCS_PREFIX = "langflow_docs_"
COMPONENT_PREFIX = "component_"
SAMPLE_PREFIX = "sample_"

LANGFLOW_DOCS_URL = "https://docs.langflow.org/develop-application"
MARKDOWN_DOCS_PATH = (
    "/Users/pedropacheco/Projects/dev/langflow.current/docs/docs/Components"
)
COMPONENT_CODE_PATH = "/Users/pedropacheco/Projects/dev/langflow.current/src/backend/base/langflow/components"
SAMPLE_CODE_PATH = "/Users/pedropacheco/Projects/dev/langflow.current/src/backend/base/langflow/initial_setup/starter_projects"


@pytest.fixture(scope="module", autouse=True)
def setup_test_directories():
    """Create and clean test output directory before tests."""
    # Setup directory
    TEST_OUTPUT_DIR.mkdir(parents=True, exist_ok=True)

    # Clean existing files
    for file in TEST_OUTPUT_DIR.glob("*"):
        if file.is_file():
            file.unlink()

    yield

    # Optionally clean up after tests
    # shutil.rmtree(TEST_OUTPUT_DIR)


@pytest.fixture
def mock_http_response():
    """Mock HTTP response for testing web page parsing."""
    with open(
        Path(__file__).parent / "fixtures" / "sample_webpage.html",
        "r",
        encoding="utf-8",
    ) as f:
        sample_html = f.read()

    mock_response = MagicMock()
    mock_response.text = sample_html
    mock_response.raise_for_status = MagicMock()
    return mock_response


@pytest.fixture
def event_loop():
    """Create an event loop for tests."""
    loop = asyncio.get_event_loop_policy().new_event_loop()
    yield loop
    loop.close()


class TestAsyncPageContentParser:
    """Tests for AsyncPageContentParser."""

    @pytest.fixture
    def parser(self):
        return AsyncPageContentParser()

    @pytest.mark.asyncio
    async def test_webpage_parsing(self, parser):
        """Test parsing a real web page."""
        url = LANGFLOW_DOCS_URL

        # Create input and output queues
        input_queue = asyncio.Queue()
        await input_queue.put(url)
        await input_queue.put(None)  # Signal end of processing

        # Run the parser with queue-based processing
        results = []
        await parser.run(input_queue, results)

        # Write results to file for inspection
        output_path = TEST_OUTPUT_DIR / HTML_OUTPUT_FILE
        with open(output_path, "w", encoding="utf-8") as f:
            json.dump(results, f, indent=2)

        # Basic validation
        assert len(results) > 0
        assert isinstance(results[0], dict)

        # Check if we have content sections
        section_keys = list(results[0].keys())
        assert len(section_keys) > 0

        print(f"Web page parsing test complete. Check {output_path} for results.")

    @pytest.mark.asyncio
    async def test_empty_url(self, parser):
        """Test with empty URL."""
        result = await parser._process_item("")
        assert isinstance(result, dict)
        assert len(result) == 0

    @pytest.mark.asyncio
    async def test_invalid_url(self, parser):
        """Test with invalid URL."""
        result = await parser._process_item(
            "https://example.com/nonexistent-page-12345"
        )
        assert isinstance(result, dict)
        assert len(result) == 0

    @pytest.mark.asyncio
    async def test_non_string_input(self, parser):
        """Test with non-string input."""
        with pytest.raises(TypeError):
            await parser._process_item(123)


class TestAsyncMarkdownParser:
    """Tests for AsyncMarkdownParser."""

    @pytest.fixture
    def parser(self):
        return AsyncMarkdownParser()

    @pytest.mark.asyncio
    async def test_parse_markdown_directory(self, parser):
        """Test parsing markdown files from a directory."""
        # Setup
        md_path = Path(MARKDOWN_DOCS_PATH)
        if not md_path.exists():
            pytest.skip(f"Markdown docs directory not found: {MARKDOWN_DOCS_PATH}")

        # Process all markdown files in the directory
        input_queue = asyncio.Queue()

        # Add files to the queue
        files_found = 0
        for file_path in md_path.glob("**/*.md"):
            await input_queue.put(str(file_path))
            files_found += 1

        if files_found == 0:
            pytest.skip("No markdown files found in the specified directory")

        await input_queue.put(None)  # Signal end of processing

        # Process the files
        results = {}
        await parser.run(input_queue, results)

        # Save results for inspection
        for file_key, content in results.items():
            filename = f"{MARKDOWN_PREFIX}{Path(file_key).stem}.json"
            output_path = TEST_OUTPUT_DIR / filename
            with open(output_path, "w", encoding="utf-8") as f:
                json.dump(content, f, indent=2)

        # Validate
        assert len(results) > 0

        # Check at least one file was processed completely
        for content in results.values():
            if len(content) > 0:
                break
        else:
            pytest.fail("No content was parsed from any markdown file")

        print(f"Markdown parsing test complete. Check {TEST_OUTPUT_DIR} for results.")

    @pytest.mark.asyncio
    async def test_nonexistent_file(self, parser):
        """Test with nonexistent file."""
        result = await parser._process_item("/path/to/nonexistent-file.md")
        assert isinstance(result, dict)
        assert len(result) == 0


class TestAsyncLangflowDocsMarkdownParser:
    """Tests for AsyncLangflowDocsMarkdownParser."""

    @pytest.fixture
    def parser(self):
        return AsyncLangflowDocsMarkdownParser()

    @pytest.mark.asyncio
    async def test_parse_langflow_docs(self, parser):
        """Test parsing Langflow documentation files."""
        # Setup
        md_path = Path(MARKDOWN_DOCS_PATH)
        if not md_path.exists():
            pytest.skip(f"Langflow docs directory not found: {MARKDOWN_DOCS_PATH}")

        # Process all markdown files in the directory
        input_queue = asyncio.Queue()

        # Add files to the queue
        files_found = 0
        for file_path in md_path.glob("**/*.md"):
            await input_queue.put(str(file_path))
            files_found += 1

        if files_found == 0:
            pytest.skip("No markdown files found in the specified directory")

        await input_queue.put(None)  # Signal end of processing

        # Process the files
        results = {}
        await parser.run(input_queue, results)

        # Save results for inspection
        for file_key, content in results.items():
            filename = f"{LANGFLOW_DOCS_PREFIX}{Path(file_key).stem}.json"
            output_path = TEST_OUTPUT_DIR / filename
            with open(output_path, "w", encoding="utf-8") as f:
                json.dump(content, f, indent=2)

        # Validate
        assert len(results) > 0

        # Check structure of parsed content
        for file_key, content in results.items():
            # LangflowDocsMarkdownParser should create sections
            if content:  # Skip empty results
                assert isinstance(content, dict)
                break
        else:
            pytest.fail("No content was properly parsed from Langflow docs")

        print(
            f"Langflow docs parsing test complete. Check {TEST_OUTPUT_DIR} for results."
        )


class TestAsyncPythonComponentParser:
    """Tests for AsyncPythonComponentParser."""

    @pytest.fixture
    def parser(self):
        return AsyncPythonComponentParser()

    @pytest.mark.asyncio
    async def test_parse_python_components(self, parser):
        """Test parsing Python component files."""
        # Setup
        components_path = Path(COMPONENT_CODE_PATH)
        if not components_path.exists():
            pytest.skip(f"Components directory not found: {COMPONENT_CODE_PATH}")

        # Process all Python files in the directory
        input_queue = asyncio.Queue()

        # Add files to the queue
        files_found = 0
        for file_path in components_path.glob("**/*.py"):
            await input_queue.put(str(file_path))
            files_found += 1

        if files_found == 0:
            pytest.skip("No Python files found in the components directory")

        await input_queue.put(None)  # Signal end of processing

        # Process the files
        results = {}
        await parser.run(input_queue, results)

        # Save results for inspection
        for file_key, content in results.items():
            rel_path = (
                Path(file_key).relative_to(components_path)
                if file_key.startswith(str(components_path))
                else Path(file_key).name
            )
            safe_path = str(rel_path).replace("/", "_").replace("\\", "_")
            filename = f"{COMPONENT_PREFIX}{safe_path}.json"
            output_path = TEST_OUTPUT_DIR / filename
            with open(output_path, "w", encoding="utf-8") as f:
                json.dump(content, f, indent=2)

        # Validate
        assert len(results) > 0

        # Check for expected content structure in at least one file
        for content in results.values():
            if isinstance(content, dict) and len(content) > 0:
                break
        else:
            pytest.fail("No components were properly parsed")

        print(
            f"Python component parsing test complete. Check {TEST_OUTPUT_DIR} for results."
        )

    @pytest.mark.asyncio
    async def test_invalid_python_file(self, parser):
        """Test with invalid Python file."""
        # Create a temporary invalid Python file
        invalid_file = TEST_OUTPUT_DIR / "invalid_syntax.py"
        with open(invalid_file, "w") as f:
            f.write(
                "def this_is_invalid_python(:\n    print('missing closing parenthesis'"
            )

        result = await parser._process_item(str(invalid_file))
        assert isinstance(result, dict)

        # Should still return a dict, even if parsing failed
        assert "error" in result or len(result) == 0


class TestAsyncPythonSampleParser:
    """Tests for AsyncPythonSampleParser."""

    @pytest.fixture
    def parser(self):
        return AsyncPythonSampleParser()

    @pytest.mark.asyncio
    async def test_parse_python_samples(self, parser):
        """Test parsing Python sample files."""
        # Setup
        samples_path = Path(SAMPLE_CODE_PATH)
        if not samples_path.exists():
            pytest.skip(f"Sample code directory not found: {SAMPLE_CODE_PATH}")

        # Process all Python files in the directory
        input_queue = asyncio.Queue()

        # Add files to the queue
        files_found = 0
        for file_path in samples_path.glob("**/*.py"):
            await input_queue.put(str(file_path))
            files_found += 1

        if files_found == 0:
            pytest.skip("No Python files found in the samples directory")

        await input_queue.put(None)  # Signal end of processing

        # Process the files
        results = {}
        await parser.run(input_queue, results)

        # Save results for inspection
        for file_key, content in results.items():
            rel_path = (
                Path(file_key).relative_to(samples_path)
                if file_key.startswith(str(samples_path))
                else Path(file_key).name
            )
            safe_path = str(rel_path).replace("/", "_").replace("\\", "_")
            filename = f"{SAMPLE_PREFIX}{safe_path}.json"
            output_path = TEST_OUTPUT_DIR / filename
            with open(output_path, "w", encoding="utf-8") as f:
                json.dump(content, f, indent=2)

        # Validate
        assert len(results) > 0

        # Check structure of at least one processed file
        for content in results.values():
            # There should be content with code sections
            if isinstance(content, dict) and any(
                key for key in content.keys() if "code" in key.lower()
            ):
                break
        else:
            for content in results.values():
                if content and len(content) > 0:
                    break
            else:
                pytest.fail("No sample code was properly parsed")

        print(
            f"Python sample parsing test complete. Check {TEST_OUTPUT_DIR} for results."
        )


# Additional fixtures needed for proper testing


@pytest.fixture(scope="module")
def sample_webpage_fixture():
    """Create a sample HTML fixture file if it doesn't exist."""
    fixtures_dir = Path(__file__).parent / "fixtures"
    fixtures_dir.mkdir(parents=True, exist_ok=True)

    sample_file = fixtures_dir / "sample_webpage.html"

    if not sample_file.exists():
        html_content = """
        <!DOCTYPE html>
        <html>
        <head>
            <title>Sample Page for Testing</title>
        </head>
        <body>
            <h1>Main Title</h1>
            <p>This is a paragraph under the main title.</p>
            
            <h2>Section 1</h2>
            <p>This is content in section 1.</p>
            <p>More content in section 1.</p>
            
            <h2>Section 2</h2>
            <p>This is content in section 2.</p>
            <ul>
                <li>List item 1</li>
                <li>List item 2</li>
            </ul>
            
            <h2>Section 3</h2>
            <table>
                <tr>
                    <th>Column 1</th>
                    <th>Column 2</th>
                </tr>
                <tr>
                    <td>Data 1</td>
                    <td>Data 2</td>
                </tr>
            </table>
        </body>
        </html>
        """

        with open(sample_file, "w", encoding="utf-8") as f:
            f.write(html_content)

    return sample_file
